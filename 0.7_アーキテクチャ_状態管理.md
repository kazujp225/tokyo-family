# 0.7 アーキテクチャ・状態管理

## 文書情報
- **作成日**: 2025-10-20
- **対象**: Tokyo Friends iOS App (仮称)
- **バージョン**: v1.0 (MVP)
- **想定プラットフォーム**: iOS 16以上（推奨：iOS 17+）

---

## 1. 目的

本文書は、iOSクライアントの**技術的アーキテクチャ**（フレームワーク・レイヤー構成・状態管理・通信戦略）を定義し、保守性・拡張性・テスタビリティを担保します。

### 狙い
- SwiftUI / UIKit併用の方針を明確化
- 状態管理パターン（MVVM / Observation）の標準化
- ネットワーク・キャッシュ・エラーハンドリングの統一戦略を確立

【MAT参照：6. iOSクライアント設計】

---

## 2. アーキテクチャ原則

### P1: 単方向データフロー
- **UI → Action → State → UI**の一方向性を保つ
- ViewModel / Store が状態の唯一の真実の源（Single Source of Truth）

### P2: レイヤー分離
- **Presentation** (View / ViewModel) ↔ **Domain** (UseCase) ↔ **Data** (Repository / API)
- 各レイヤーは疎結合（Protocol / Dependency Injection）

### P3: テスタビリティ
- 依存をProtocolで抽象化（モック注入可能）
- ビジネスロジックはViewModel / UseCaseに集約（View非依存）

### P4: iOS標準優先
- Apple公式フレームワーク・パターンを優先
- サードパーティは最小限（依存管理コスト削減）

---

## 3. フレームワーク・主要ライブラリ

### 3.1 UI

| 技術 | 用途 | 備考 |
|---|---|---|
| **SwiftUI** | メインUI（ホーム・探索・設定等） | iOS 16+ の新機能活用（Observation） |
| **UIKit** | 一部補完（複雑なカスタムビュー） | UIViewRepresentable でラップ |
| **Combine** | 非同期データバインディング | SwiftUIと親和性高 |

**方針**:
- 新規画面はSwiftUI優先
- UIKitは既存資産・複雑なアニメーション等で限定使用

### 3.2 通信

| 技術 | 用途 | 備考 |
|---|---|---|
| **URLSession** | HTTP通信（REST API） | HTTP/2対応、再試行ポリシー実装 |
| **Codable** | JSON シリアライズ / デシリアライズ | Swift標準、型安全 |
| **Async/Await** | 非同期処理 | iOS 15+ 標準、可読性高 |

**方針**:
- サードパーティHTTPライブラリ不使用（Alamofireは導入しない）
- 再試行・タイムアウトは独自実装（指数バックオフ）

### 3.3 位置情報

| 技術 | 用途 | 備考 |
|---|---|---|
| **Core Location** | 概略位置取得（区・最寄駅推定） | バックグラウンド常時取得は**行わない** |

**方針**:
- 初回オンボーディング時のみ位置取得（ユーザー同意後）
- 区・最寄駅の推定に利用、生座標はサーバー送信せず破棄

### 3.4 認証

| 技術 | 用途 | 備考 |
|---|---|---|
| **AuthenticationServices** | Sign in with Apple | iOS 13+ 標準 |
| **Keychain** | セッショントークン保存 | 生体認証連携可能 |

### 3.5 画像

| 技術 | 用途 | 備考 |
|---|---|---|
| **PhotosUI** | 写真選択UI（PhotosPicker） | iOS 16+ 標準 |
| **Image I/O** | EXIF除去・リサイズ・圧縮 | Core Graphics ベース |
| **URLCache** | 画像キャッシュ | 標準キャッシュ戦略 |

**方針**:
- サードパーティ画像ライブラリ不使用（Kingfisher等は導入しない）
- AsyncImageでリモート画像表示、プレースホルダ対応

### 3.6 通知

| 技術 | 用途 | 備考 |
|---|---|---|
| **UserNotifications** | ローカル・リモート通知 | iOS 10+ 標準 |
| **APNs** | プッシュ通知配信 | Apple Push Notification service |

### 3.7 セキュリティ

| 技術 | 用途 | 備考 |
|---|---|---|
| **Keychain** | 機密データ保存（セッショントークン） | 生体認証・iCloud同期対応 |
| **CryptoKit** | ハッシュ・HMAC生成 | iOS 13+ 標準 |
| **DeviceCheck / App Attest** | 端末信頼性検証 | スパム端末抑止 |

【MAT参照：6.1. フレームワーク/主要コンポーネント】

---

## 4. レイヤー構成

### 4.1 全体構造

```
┌─────────────────────────────────────┐
│      Presentation Layer             │
│  (View / ViewModel / Router)        │
├─────────────────────────────────────┤
│      Domain Layer                   │
│  (Entity / UseCase / Repository IF) │
├─────────────────────────────────────┤
│      Data Layer                     │
│  (Repository Impl / API / Cache)    │
└─────────────────────────────────────┘
```

---

### 4.2 Presentation Layer（プレゼンテーション層）

**責務**: UI表示とユーザー操作の受付

#### View（SwiftUI）
- 状態を表示（ViewModel / State を購読）
- ユーザー操作を ViewModel へ委譲
- ビジネスロジック非保持（薄いView）

#### ViewModel（ObservableObject / @Observable）
- 状態を保持（@Published / @State でバインディング）
- UseCaseを呼び出し、結果を状態へ反映
- UIロジックのみ（例: フィールドバリデーション、エラー表示制御）

**例**:
```
@Observable class ExploreViewModel {
  var cards: [CardModel] = []
  var isLoading = false
  var errorMessage: String?

  private let fetchCardsUseCase: FetchCardsUseCaseProtocol

  init(fetchCardsUseCase: FetchCardsUseCaseProtocol) {
    self.fetchCardsUseCase = fetchCardsUseCase
  }

  func loadCards() async {
    isLoading = true
    do {
      cards = try await fetchCardsUseCase.execute()
      isLoading = false
    } catch {
      errorMessage = error.localizedDescription
      isLoading = false
    }
  }
}
```

#### Router
- 画面遷移ロジックを集約（NavigationPath管理）
- Deep Link ハンドリング

---

### 4.3 Domain Layer（ドメイン層）

**責務**: ビジネスロジックの集約

#### Entity
- ドメインモデル（例: User / Profile / Match）
- Codable準拠（JSON変換）

#### UseCase
- 単一責務（例: FetchCardsUseCase / SendLikeUseCase）
- Repository経由でデータ取得・更新
- ビジネスルール適用（例: レート制限チェック）

**例**:
```
protocol FetchCardsUseCaseProtocol {
  func execute(communityId: UUID?) async throws -> [CardModel]
}

class FetchCardsUseCase: FetchCardsUseCaseProtocol {
  private let cardRepository: CardRepositoryProtocol

  init(cardRepository: CardRepositoryProtocol) {
    self.cardRepository = cardRepository
  }

  func execute(communityId: UUID?) async throws -> [CardModel] {
    return try await cardRepository.fetchCards(communityId: communityId)
  }
}
```

#### Repository Protocol
- データソースの抽象化（Protocol定義）
- Data LayerのRepositoryが実装

---

### 4.4 Data Layer（データ層）

**責務**: データソースとの通信

#### Repository Implementation
- API / Cacheを組み合わせてデータ取得
- エラーハンドリング（ドメインエラーへ変換）

**例**:
```
protocol CardRepositoryProtocol {
  func fetchCards(communityId: UUID?) async throws -> [CardModel]
}

class CardRepository: CardRepositoryProtocol {
  private let apiClient: APIClientProtocol
  private let cache: CacheProtocol

  func fetchCards(communityId: UUID?) async throws -> [CardModel] {
    // 1. キャッシュチェック
    if let cachedCards = cache.get(key: "cards") {
      return cachedCards
    }

    // 2. API呼び出し
    let cards = try await apiClient.get("/feed", params: ["community_id": communityId])

    // 3. キャッシュ保存
    cache.set(key: "cards", value: cards, expiration: 3600)

    return cards
  }
}
```

#### APIClient
- URLSession ラッパー
- 共通処理（認証ヘッダー付与・再試行・エラー変換）

#### Cache
- インメモリ / UserDefaults / Keychain を抽象化
- 有効期限管理

【MAT参照：6.1. フレームワーク】

---

## 5. 状態管理戦略

### 5.1 ローカル状態（画面単位）

**方針**: SwiftUI標準（@State / @Observable）

**適用対象**:
- テキスト入力中の値
- モーダル開閉フラグ
- 一時的なUI状態

**例**:
```
struct LoginView: View {
  @State private var phoneNumber = ""
  @State private var isShowingError = false

  var body: some View {
    TextField("電話番号", text: $phoneNumber)
  }
}
```

---

### 5.2 共有状態（アプリ全体）

**方針**: EnvironmentObject / @Observable

**適用対象**:
- ログイン状態（セッショントークン）
- 現在のユーザープロフィール
- 通知バッジカウント

**例**:
```
@Observable class AppState {
  var currentUser: User?
  var isLoggedIn: Bool { currentUser != nil }
  var unreadNotificationCount = 0
}

// App.swift
@main
struct TokyoFriendsApp: App {
  @State private var appState = AppState()

  var body: some Scene {
    WindowGroup {
      ContentView()
        .environment(appState)
    }
  }
}

// View
struct HomeView: View {
  @Environment(AppState.self) var appState

  var body: some View {
    Text("こんにちは、\(appState.currentUser?.name ?? "")")
  }
}
```

---

### 5.3 永続化状態

**方針**: レイヤー別保存戦略

| データ種別 | 保存先 | 有効期限 | 例 |
|---|---|---|---|
| 機密トークン | Keychain | セッション有効期限 | セッショントークン |
| ユーザー設定 | UserDefaults | 永続 | 通知ON/OFF |
| キャッシュ | URLCache / メモリ | 短期（1h〜24h） | プロフィール・画像 |

---

## 6. 通信戦略

### 6.1 API通信（URLSession）

#### 基本構造

```
class APIClient {
  private let baseURL = "https://api.tokyofriends.app"
  private let session: URLSession

  init() {
    let config = URLSessionConfiguration.default
    config.timeoutIntervalForRequest = 30
    config.httpMaximumConnectionsPerHost = 5
    self.session = URLSession(configuration: config)
  }

  func get<T: Codable>(_ path: String, params: [String: Any]? = nil) async throws -> T {
    // 1. URLRequest構築
    var request = URLRequest(url: URL(string: baseURL + path)!)
    request.httpMethod = "GET"
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")

    // 2. 認証ヘッダー付与
    if let token = Keychain.shared.get(key: "session_token") {
      request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
    }

    // 3. 実行（再試行あり）
    return try await executeWithRetry(request: request)
  }
}
```

#### 再試行ポリシー（指数バックオフ）

```
func executeWithRetry<T: Codable>(request: URLRequest, maxRetries: Int = 3) async throws -> T {
  var lastError: Error?

  for attempt in 0..<maxRetries {
    do {
      let (data, response) = try await session.data(for: request)

      guard let httpResponse = response as? HTTPURLResponse else {
        throw NetworkError.invalidResponse
      }

      // レート制限（429）は指数バックオフ
      if httpResponse.statusCode == 429 {
        let delay = pow(2.0, Double(attempt)) * 1.0 // 1s → 2s → 4s
        try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
        continue
      }

      // 成功（2xx）
      if (200...299).contains(httpResponse.statusCode) {
        return try JSONDecoder().decode(T.self, from: data)
      }

      // その他エラー
      throw NetworkError.httpError(statusCode: httpResponse.statusCode)

    } catch {
      lastError = error
    }
  }

  throw lastError ?? NetworkError.unknown
}
```

【MAT参照：6.1. フレームワーク / 8.6. エラー/レート制限】

---

### 6.2 キャッシュ戦略

#### 画像キャッシュ（URLCache）

```
let config = URLSessionConfiguration.default
config.urlCache = URLCache(
  memoryCapacity: 50 * 1024 * 1024,  // 50MB
  diskCapacity: 100 * 1024 * 1024,   // 100MB
  diskPath: "images"
)
```

#### APIレスポンスキャッシュ（メモリ / UserDefaults）

| エンドポイント | キャッシュ先 | 有効期限 | 理由 |
|---|---|---|---|
| GET `/me` | メモリ | 24時間 | 頻繁にアクセス、変更少 |
| GET `/feed` | メモリ | 1時間 | カード一覧はリアルタイム性重視 |
| GET `/communities` | メモリ | 6時間 | 更新頻度低 |

---

### 6.3 エラーハンドリング

#### エラー種別

```
enum NetworkError: Error, LocalizedError {
  case invalidResponse
  case httpError(statusCode: Int)
  case decodingError
  case networkUnavailable
  case rateLimitExceeded

  var errorDescription: String? {
    switch self {
    case .invalidResponse:
      return "無効なレスポンスです"
    case .httpError(let code):
      return "エラーが発生しました（\(code)）"
    case .decodingError:
      return "データの解析に失敗しました"
    case .networkUnavailable:
      return "インターネット接続を確認してください"
    case .rateLimitExceeded:
      return "しばらくしてから再度お試しください"
    }
  }
}
```

#### エラー表示（View）

```
struct ExploreView: View {
  @State private var viewModel = ExploreViewModel()

  var body: some View {
    ZStack {
      // コンテンツ
      CardDeckView(cards: viewModel.cards)

      // エラーバナー
      if let errorMessage = viewModel.errorMessage {
        VStack {
          Spacer()
          ErrorBannerView(message: errorMessage) {
            Task { await viewModel.loadCards() }
          }
        }
        .transition(.move(edge: .bottom))
      }
    }
  }
}
```

【MAT参照：15. エラー/オフライン設計】

---

## 7. セキュリティ実装

### 7.1 セッショントークン管理

**保存**: Keychain（生体認証付き）

```
class Keychain {
  static let shared = Keychain()

  func set(key: String, value: String) {
    let query: [String: Any] = [
      kSecClass as String: kSecClassGenericPassword,
      kSecAttrAccount as String: key,
      kSecValueData as String: value.data(using: .utf8)!,
      kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
    ]
    SecItemAdd(query as CFDictionary, nil)
  }

  func get(key: String) -> String? {
    let query: [String: Any] = [
      kSecClass as String: kSecClassGenericPassword,
      kSecAttrAccount as String: key,
      kSecReturnData as String: true
    ]

    var result: AnyObject?
    SecItemCopyMatching(query as CFDictionary, &result)

    guard let data = result as? Data else { return nil }
    return String(data: data, encoding: .utf8)
  }
}
```

---

### 7.2 EXIF位置情報除去

```
func removeEXIF(from image: UIImage) -> Data? {
  guard let data = image.jpegData(compressionQuality: 0.8),
        let source = CGImageSourceCreateWithData(data as CFData, nil),
        let uti = CGImageSourceGetType(source) else {
    return nil
  }

  let metadata: [String: Any] = [
    kCGImagePropertyGPSDictionary as String: kCFNull,
    kCGImagePropertyOrientation as String: 1
  ]

  let mutableData = NSMutableData()
  guard let destination = CGImageDestinationCreateWithData(mutableData, uti, 1, nil) else {
    return nil
  }

  CGImageDestinationAddImageFromSource(destination, source, 0, metadata as CFDictionary)
  CGImageDestinationFinalize(destination)

  return mutableData as Data
}
```

【MAT参照：5.2. セキュリティ/プライバシー】

---

## 8. Plan-MD 参照マップ

| 本文書セクション | Plan-MD 参照箇所 |
|---|---|---|
| 1. 目的 | 6. iOSクライアント設計 |
| 3. フレームワーク | 6.1. フレームワーク/主要コンポーネント |
| 4. レイヤー構成 | 6.1 |
| 6. 通信戦略 | 6.1、8.6. エラー/レート制限、15. エラー/オフライン |
| 7. セキュリティ実装 | 5.2. セキュリティ/プライバシー |

---

## 9. 補足

### 9.1 更新履歴
| 日付 | 変更内容 | 担当 |
|---|---|---|
| 2025-10-20 | 初版作成 | 開発・アーキテクト |

---

**次に読むべき文書**: `0.8_非機能_セキュリティ_性能.md`（非機能要件詳細）
